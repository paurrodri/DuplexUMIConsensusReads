---
title: "DuplexUMIConsensusReads documentation"
output:
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: yes
---
  
```{css, echo=FALSE}
body .main-container {
  max-width: 1280px !important;
  width: 1280px !important;
}
body {
  max-width: 1280px !important;
}
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<br/>

# **Summary**

`DuplexUMIConsensusReads` calls consensus reads from input reads generated from the same double-stranded DNA molecule.

These input reads are assumed to:

* be generated from paired-end sequencing 

* be generated from DNA fragments with Unique Molecular Identifiers (UMIs) attached in both ends (Duplex-UMIs).

  
The mathematical and probabilistic procedure to determine the consensus sequence is based on [fulcrumgenomics CallMolecularConsensusReads tool](https://github.com/fulcrumgenomics/fgbio/wiki/Calling-Consensus-Reads).
  
The novel feature of this tool is the fact that mapping information of the consensus reads is also computed. This includes _mapping position_, _mapping quality_ and _CIGAR string_ fields. Therefore, there is no need to map the consensus reads again after using this tool. 

This feature is contained in the script function `make_consensus_read()`, which is the core of the script and is explained in this [Section](#function).

<br/>


# **How to use**
<br/>

## Installation

Download the script `DuplexUMIConsensusReads.py`

or clone the repository:
```
git clone https://github.com/paurrodri/DuplexUMIConsensusReads.git
```
<br/>

## Dependencies

`DuplexUMIConsensusReads` is dependent on Python >= 3.6. 
  
It requires the following libraries:

* sys
* argparse
* math
* random
* numpy
* pysam

<br/>

## Usage

Run:
```
python3 DuplexUMIConsensusReads.py -i <inputfile.bam>
``` 
<br/>

### Required arguments

The only required argument is the **input file**, given with `-i` or `--input_file`.
  
The input file is assumed to:

* be a binary Sequence Alignment/Map file (`.bam` format)
* have reads generated by paired-end sequencing, from a library with Duplex Unique Molecular Identifiers (Duplex-UMI) attached to the DNA fragments
* have the reads sorted by position
* have the Duplex-UMI sequence specified in every read, with the tag `RX`
* have the family code specified in every read, with the tag `MI`. This family code is unique for each combination of Duplex UMI sequences

The current version of `DuplexUMIConsensusReads` is recommended to be used for input files that had been processed by [fulcrumgenomics GroupReadsByUMI tool](http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html)

<br/>

### Optional arguments

Optional arguments in `DuplexUMIConsensusReads` are:

| argument | flag | long option | type | description | default |
|------------------------------------|------|----------------------------|------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------|
| output file | -o | --output_file | str | name of the output .bam file with consensus reads | <input_filename>_cons.bam |
| verbose | -v | --verbose |  | add this option to display how the program is running |  |
| minimum mapping quality | -q | --min_map_quality | int | minimum mapping quality (given as Phred score) of a read to be used to generate the consensus read | 20                                                                                                                                                                                                      |
| minimum base quality |  | --min_base_quality | int | minimum base quality (given as Phred score) for a base not to be masked | 20                                                                                                                                                                                                      |
| minimum read number |  | --min_reads | int | minimum number of reads from the same sub-family to generate a single-strand consensus read | 1         |
| maximum read number |  | --max_reads | int | maximum number of reads from the same sub-family to generate a single-strand consensus read | 100                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| maximum base quality |  | --max_base_quality | int | Recommended to use in case of overestimated base qualities. All bases with a quality greather than this value (given as a Phred score) will be capped before calling consensus. | 60                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| base quality shift |  | --base_quality_shift | int | Recommended to use in case of overestimated base qualities. All base qualities will be substracted this value (given as a Phred score) before calling consensus. | 0 |
| error rate post labeling |  | --error_rate_post_labeling | int | Recommended to use in case of having prior knowledge about this error. Error rate for an error after the UMIs have been integrated to the fragment, but prior to sequencing. Given as a Phred score. | 0 |
| error rate pre labeling |  | --error_rate_pre_labeling | int | Recommended to use in case of having prior knowledge about this error. Error rate for an errror before the UMIs have been integrated to the fragment. Given as a Phred score. | 0 |
| deletion score |  | --deletion_score | int | quality score (Phred score) for a deletion | 30                                                                                                                                                                                                                                                                                                          |
| score for the absence of insertion |  | --no_insertion_score | int | Quality score (Phred score) for the "absence of an insertion". This refers to reads not having any insertion in a position where other reads from the same family have an insertion. | 30                                                                                                                                                                                                                                                                                                          |

<br/>

## Help

To get inline help about the usage and arguments, run: 
```
python3 DuplexUMIConsensusReads.py -h
```
<br/>

# **Theoretical concepts** {#theory}
<br/>

## Paired-end sequencing 

Paired-end sequencing is a sequencing method that generates reads mapping to both ends of a DNA fragment. This way, individual reads can be aligned together to create paired-end reads, which is convinient for several reasons:

* greater ability to detect insertion-deletion (INDEL) variants as well as repeated elements, which is not possible with single reads

* it produces twice the number of reads for the same time and effort in library preparation

![](figs/pairedend.png){ width=60% }

<br/>

## Duplex Unique Molecular Identifiers (UMIs)

Before sequencing, the DNA fragments resulting from the library can tagged with known DNA sequences in order to identify the source DNA molecule of the resulting reads. 

These known sequences, of around 6bp, are known as Unique Molecular Identifiers (UMIs). 

They can be attached to one end of the DNA fragment or to the two ends. The latter are known as DuplexUMIs, and these type of reads are what ```DuplexUMIConsensusReads``` processes. 

![](figs/duplexUMIs.png){ width=60% }

<br/>


## Family {#family}
The concept of "family" refers to a group of reads that:

* map to the same position

* have the same Duplex UMI sequence


In other words: reads coming from the same source molecule.

Reads from the same family are given a family code (e.g. a number). In the current version of this script, we expect this code to be included in the optional tag ```MI```.

These reads can be either from the forward DNA strand or the reverse DNA strand molecule; they can also be either the first pair or the second pair. They all belong to the same family, and the terminology used for these subgroups is the following:

* A1: first pair, maps forward strand

* A2: second pair, maps reverse strand

* B1: first pair, maps reverse strand

* B2: second pair, maps forward strand

![](figs/family0.png){ width=75% }
![](figs/familyAB.png){ width=75% }

<br/>

## Consensus reads

When having multiple reads coming from the same DNA source molecule (i.e. the same family), one can detect which nucleotide mutations are not real mutations, but technical errors in the sequencing process, as they are present in a minor number of reads.

In order to reduce the number of technical errors, one can generate a **consensus sequence**, formed by the most likely nucleotides at each position, considering all the sequences from the input reads. 

This way, variant detection improves considerably, since mutations are more likely to be real mutations, rather than technical errors during sequencing.

![](figs/consensus_basic.png){ width=40% }

<br/>

### Consensus reads in Duplex-UMI paired-end sequencing {#duplexconsensus}

As seen in [Family section](#family), reads from the same source DNA fragment can be grouped into four categories. 

The first step to generate the consensus read of the family (i.e. representing the source DNA fragment), is generating **single-strand consensus reads** for each subfamily. 

One can see that sequences from subfamily A1 (strand A - forward) and B2 (strand B - reverse) map to the same position, as well as the sequences from subfamily A2 (strand A - forward) and B1 (strand B - reverse). 

Therefore, once the four single-strand consensus are computed, A1 and B2 consensus will be grouped and used as input to create a **double-strand consensus read**; as well as B1 and A2 single-consensus will be used as input to create a second double-strand consensus read.

This will result in two double-strand consensus reads for each family: one mapping to the forward strand (A1-B2), and one mapping to the reverse strand (B1-A2).

_Note that a read coming from the forward strand (A1, A2) is different than a read mapping to the forward strand (A1, B2)_

![](figs/doubleconsensus.png){ width=75% }

For more detailed information on how to generate consensus reads, please visit  [make_consensus_read() function](#function).

<br/>

# **Pipeline**
<br/>

## Input

```DuplexUMIConsensusReads``` takes a _.bam_ file as input. Other file format will not be accepted and an error will raise, ending the execution.

The reads in the input _.bam_ file are assumed to:

* be generated from paired-end sequencing 

* be generated from DNA fragments with Unique Molecular Identifiers (UMIs) attached in both ends (Duplex-UMIs)

* include an optional tag, ```RX```, containing their corresponding DuplexUMI sequence

* include an optional tag, ```MI```, containing the family they belong to. 

* be sorted in the file according to their mapping position and their family code (`MI`tag)


The current version of `DuplexUMIConsensusReads` is recommended to be used for input files that had been processed by [fulcrumgenomics GroupReadsByUMI tool](http://fulcrumgenomics.github.io/fgbio/tools/latest/GroupReadsByUmi.html). 

If changes are made in [Step 2: add read into family](#step2), ```MI``` tag might be no longer needed (note that the error handling for the presence of ```MI``` tag in Step 1 would also need to be erased). 

<br/>

Once the input file is read, `DuplexUMIConsensusReads` loads the input reads iteratively. For each read loaded, the script goes through the following steps:
  
<br/>  

## 1. Filter read {#step1}

Only reads meeting all the following conditions will be considered for the next steps:

* read is paired

* read is proper pair

* read is mapped

* mate is mapped

* read is primary alignment 

* read does not fail QC

* mapping quality > threshold (given as argument ```--min_map_quality``` or ```-q```)


This step also included a checkpoint for some possible errors in the read. If any of the following conditions is not met, an error will be raised and the program will stop:

* ```MI``` tag present (containing family code)

* ```RX``` tag present (containing UMI sequence)

* Absence of symbols ```P``` (padding), ```N``` (skipped), ```*``` (nothing) in CIGAR string

* Softclips are only in the ends of the CIGAR string
 
The code executing this step is contained in the function ```pass_filters(read)```. 
  
<br/>

## 2. Add read into a family {#step2}

If the read has passed all the filters in [Step 1](#step1), it will be added to the family it belongs to. 

Three situations can occur:

* **The input read is the first read in the file**: therefore, no family has been loaded yet. The `read` will be added to a new `family` variable and the `family_code` will be set to the read's `MI` tag. Next, the program will load a new read and start [Step 1](#step1) again. 

* **The input read belongs to the currently-loaded family** (`MI` tag of read == `family_code`): the `read` will be appended to a to the `family` variable. Next, the program will load a new read and start [Step 1](#step1) again.

* **The input read does not belong to the currently-loaded family** (`MI` tag of read != `family_code`): the `read` will be added to a new variable named `next_family`. The currently-loaded family will be considered as completely-loaded and the program will proceed with [Step 3](#step3). After processing the current family and generating the consensus reads for that family, the read stored in `next_family` will be moved the variable `family`, so that the next family is ready to be processed (done in `load_next_family()` function).


As it can be observed, the structure of this Step requires that the input file has the reads sorted by family. 

The code executing this step is contained in the function ```add_read_to_family(read, family, family_code)```.

**NOTE**: this function can be changed in the future if another type of _.bam_ input file is desired to be used (note that the checkpoints in [Step 1](#step1) for the presence of `MI`and `RX` tags might need to be removed too). 

<br/>

## 3. Pre-process the family {#step3}

Once the current family has been completely loaded (`next_family != None`) in [Step 2](#step2), their corresponding consensus sequences can be generated. 

Before that a pre-processing step is needed. The code executing this step is contained in the function `preprocess_family(family, family_code)`. It includes the following sub-steps:

<br/>

### 3.1. Checkpoint for possible errors in the family

If any of the following conditions is not met, an error is raised and the program exits:

  * All the reads in the family have the same DuplexUMIs sequences (either UMI1-UMI2 or UMI2-UMI1) - done in function `check_family_UMIs(family, family_code)`
  
  * All the reads in the family have the same value in the `rname` field (e.g. chromosome number) - done in function `check_family_rnames(family, family_code)`. _For more information about `rname` field and other SAM format specifications, please visit [SAM documentation](https://samtools.github.io/hts-specs/SAMv1.pdf)_

<br/>

### 3.2. Split the family

As stated in [Theoretical Concepts](#theory) section, families can be divided into four groups, depending on whether the read maps to the forward or reverse strand and whether it is first or second paired-end.

In this sub-step, the variable `family` will be converted from a list of reads to a list of four lists of reads, corresponding to each group. This is done in function `split_family(family)`. 

<br/>

### 3.3 Check number of reads on each subfamily

In order to generate decent consensus sequences, a minumum number of reads in each subfamily/group is necessary. This threshold can passed to the script with the argument `--min_reads`.
If any of the subfamilies contains a number of reads below this threshold, the family stops being processed and the program loads the next read and starts [Step 1](#step1) again.

The opposite situation can arise: if any subfamily contains a number of reads above another threshold (which can passed to the script with the argument `--max_reads`), the reads in that subfamily will be randomly downsampled to the threshold value. This is done in order to reduce the computation time when calling the consensus sequence.

The code executing this sub-step is in function `check_number_reads(family, min_reads, max_reads)`.


If all the subfamilies contained a greater or equal number of reads than the threshold, the pre-processing step can continue. The following steps are done per read.

<br/>

### 3.4 Remove read's clips

For each read, hard clips and soft clips are removed from the read's sequence, base qualities and CIGAR string.

It assumes that soft-clips can only be observed at the start/end of the sequence, but this would have been checked in the error checkpoint of [Step 1](#step1).

The code executing this sub-step is in function `remove_clipping(read)`.

<br/>

### 3.5 Mask low-quality bases

For each read, all bases having a quality smaller than a threshold will be masked (transformed to "N"). This threshold can passed to the script with the argument `--min_base_quality`. This will prevent low-quality nucleotides from being considered for the consensus sequence.

The code executing this sub-step is in function `mask_low_quality_bases(read, threshold)`.

<br/>

### 3.6. Trim masked bases in 3'-end 

For each read, all masked ("N") bases in 3'-end will be trimmed. This will modify the read's sequence, base qualities and CIGAR string. 

The code executing this sub-step is in function `trim_3prime_N(read)`.

**NOTE**: a new step could be included here: 3’ low-quality trimming, instead of only 3' N trimming.

<br/>

## 4. Call single-strand consensus reads {#step4}

As explained in [Consensus reads in Duplex-UMI paired-end sequencing](#duplexconsensus), the first step in consensus calling is generating single-strand consensus reads for each subfamily. 

Therefore, the function `make_consensus_read()` will be called four times, with the reads of each subfamily as input.

The function `make_consensus_read()` is the core of the script and is explained in this [Section](#function).

*Speak about tags!*

<br/>

## 5. Call double-strand consensus reads {#step5}

Once the single-strand consensus reads have been generated, A1 and B2 consensus will be grouped; as well as B1 and A2 consensus (see [Consensus reads in Duplex-UMI paired-end sequencing](#duplexconsensus) for more details). 

The function `make_consensus_read()` (see [function](#function)) will be called twice, with the single-consensus reads from each of the two groups as input. 

This will result in two double-strand consensus reads for the current family: one mapping to the forward strand (A1-B2 - arbitrarily set as _paired-end 1_), and one mapping to the reverse strand (B1-A2 - arbitrarily set as _paired-end 2_).

*Speak about tags!*

<br/>

## 6. Fix paired-end information {#step6}

The two double-strand consensus reads resulting from [Step 5](#step5) do not have values in the mate fields (see [SAM documentation](https://samtools.github.io/hts-specs/SAMv1.pdf) for more information on .sam format specifications): `rnext` (mate reference name), `pnext` (mate starting position) and `tlen` (template length). 

In this step, the reference name and starting position of one consensus read are set in the mate fields of the other consensus read, and vice-versa. Template length is also calculated and set in the two consensus reads.

The code executing this step is contained in the function `fix_paired_end_fields (consensus_1, consensus_2)`.

<br/>

## Output {#output}
Finally, the two consensus reads for the currently-loaded family are writen in the output _cons.bam_ file.

There are two other output files:

* _filtered_reads.bam_: reads that did not pass the filters from [Step 1](#step1)
* _filtered_families.bam_: reads from the families that failed the pre-processing step ([Step 3](#step3)) due to a low number of reads in any of the subfamilies.

<br/>


# **make_consensus_read() function** {#function}

This function is the core of the script and, due to its complexity and relevance, will be explained individually in this Section. For more information about when it is used, please visit [Step 4](#step4) and [Step 5](#step5) of the pipeline.


<br/>


# **Author**

Paula Rodríguez García (<p.rodriguezgar@hotmail.com>)
  
_created for the Centre for Genomic Medicine - Rigshospitalet, Copenhagen, Denmark_  
_as part of a Master's project at the Technical University of Denmark_  
_2020_